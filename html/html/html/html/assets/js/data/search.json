[ { "title": "ReentrantLock原理分析", "url": "/posts/reentrantlock/", "categories": "Java, JDK, JUC", "tags": "Java, JDK, JUC, AQS, Lock, ReentrantLock", "date": "2021-01-10 21:48:00 +0800", "snippet": "ReentrantLock是Java并发包中提供的一个可重入的互斥锁，它拥有与synchronized相同的作用，但却比synchronized有更好的性能，在许多高并发编程中都会用到它。由于大部分同学都只停留在了API调用的层次，对ReentrantLock的原理一知半解，甚至一无所知，因此写下了这篇文章，让同学们真正的把ReentrantLock给拿下！本文将会从以下几个方面去进行分享： 使用场景 源码实现 设计思想使用场景在对象上使用：public class ReentrantLockTest { private ReentrantLock lock = new Re..." }, { "title": "计算机系统为什么要内存对齐？", "url": "/posts/computer-memory-align/", "categories": "Hardware, Memory", "tags": "Hardware, Memory, CPU", "date": "2020-12-13 18:08:00 +0800", "snippet": "有时候会遇到同学们在问：“我打印出来的Java对象大小为什么总是24bytes，32bytes，40bytes，为什么不能是25bytes，26bytes，27bytes呢？除此之外，我发现它们都是8的倍数唉，好奇怪！“。为了让这些同学不再疑惑，于是我决定写下这篇文章。本文将会从以下几个方面去分享: Java中为什么会有这个现象 如何使用C语言证明内存对齐 计算机为什么要使用内存对齐Java中为什么会有这个现象开局一张图，这是Oracle Java8的官方文档解释，茫茫英文文海里翻出来的不容易，同学们细品。官网想告诉我们的呢，其实就是内存中的Class文件是以字节流的形式存储的。所..." }, { "title": "证明CPU乱序执行的一种简单方式", "url": "/posts/cpu-exec-out-of-order/", "categories": "Hardware, CPU", "tags": "Hardware, CPU, ExecOutOfOrder", "date": "2020-09-30 22:07:00 +0800", "snippet": "上一篇文章分享了volatile的实现原理，其中提到了CPU的乱序执行，这篇文章来分享一下CPU乱序执行的一种最简单证明。将会从以下几个方面去作出分享: 如何证明CPU乱序执行 为什么要开多线程去证明如何证明CPU乱序执行通过一段很简单的Java代码就能证明CPU存在乱序执行，现在我把这段代码贴在下面。public class CpuExecOutOfOrderTest { private static int s1, s2, t1, t2; public static void main(String[] args) throws Interrupted..." }, { "title": "volatile实现原理", "url": "/posts/java-concurrent-volatile/", "categories": "Java, Concurrent", "tags": "Java, Concurrent, volatile", "date": "2020-09-15 21:30:00 +0800", "snippet": "最近学习了volatile的实现原理，有一些心得体会，写这篇文章记录一下。将会从以下几个方面去描述volatile的技术内幕: 功能特性与使用场景 字节码层面分析 JVM层面分析 CPU层面分析功能特性与使用场景保证数据可见性在多线程环境下，多个线程共享某个volatile修饰的数据。当其中一个线程修改了这个数据之后，其他线程将能及时获取到该数据的最新值。为什么当一个线程修改了volatile修饰的数据之后，其他线程能及时获取到该数据的最新值呢？可以通过下面这张图得出答案。上图的java并发内存模型并不是真实存在于计算机中的，只是抽象出来的一个概念，具体实现依赖底层操作系统和硬件..." } ]
