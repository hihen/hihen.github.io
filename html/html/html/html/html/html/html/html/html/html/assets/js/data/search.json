[ { "title": "计算机系统为什么要内存对齐？", "url": "/posts/cpu-memory-align/", "categories": "Hardware, Memory", "tags": "Hardware, Memory", "date": "2020-10-15 10:08:00 +0800", "snippet": "总会遇到一些同学在问：“张老师，我打印出来的Java对象大小为什么总是24bytes，32bytes，40bytes等等，为什么不能是25bytes，26bytes，27bytes呢？另外，我发现它们都是8的倍数唉，好奇怪！“。为了让这些同学不再疑惑，于是我决定写下这篇文章。本文将会从以下几个方面去分享: Java中这是个什么现象 C语言证明这现象的存在 为什么会出现这样的现象Java中这是个什么现象开局一幅图，这是Oracle Java8的官方文档说明，大家细品。" }, { "title": "证明CPU乱序执行的一种简单方式", "url": "/posts/cpu-exec-out-of-order/", "categories": "Hardware, CPU", "tags": "Hardware, CPU, ExecOutOfOrder", "date": "2020-09-30 22:07:00 +0800", "snippet": "上一篇文章分享了volatile的实现原理，其中提到了CPU的乱序执行，这篇文章来分享一下CPU乱序执行的一种最简单证明。将会从以下几个方面去作出分享: 如何证明CPU乱序执行 为什么要开多线程去证明如何证明CPU乱序执行通过一段很简单的Java代码就能证明CPU存在乱序执行，现在我把这段代码贴在下面。public class CpuExecOutOfOrderTest { private static int s1, s2, t1, t2; public static void main(String[] args) throws Interrupted..." }, { "title": "volatile实现原理", "url": "/posts/java-concurrent-volatile/", "categories": "Java, Concurrent", "tags": "Java, Concurrent, volatile", "date": "2020-09-15 21:30:00 +0800", "snippet": "最近学习了volatile的实现原理，有一些心得体会，写这篇文章记录一下。将会从以下几个方面去描述volatile的技术内幕: 功能特性与使用场景 字节码层面分析 JVM层面分析 CPU层面分析功能特性与使用场景保证数据可见性在多线程环境下，多个线程共享某个volatile修饰的数据。当其中一个线程修改了这个数据之后，其他线程将能及时获取到该数据的最新值。为什么当一个线程修改了volatile修饰的数据之后，其他线程能及时获取到该数据的最新值呢？可以通过下面这张图得出答案。上图的java并发内存模型并不是真实存在于计算机中的，只是抽象出来的一个概念，具体实现依赖底层操作系统和硬件..." } ]
