[ { "title": "volatile实现原理", "url": "/posts/java-volatile/", "categories": "Java, Core", "tags": "Java", "date": "2020-09-15 21:30:00 +0800", "snippet": "最近学习了volatile的实现原理，有一些心得体会，写这篇文章记录一下。将会从以下几个方面去描述volatiled的技术内幕: 功能特性与使用场景 字节码层面分析 JVM层面分析 cpu层面分析功能特性与使用场景保证数据可见性在多线程环境下，多个线程共享某个被volatile修饰的内存变量。当其中一个线程修改了这个内存变量之后，其他线程将能实时获取到该内存变量的最新值。为什么当一个线程修改了共享内存变量之后，其他线程能实时获取到该内存变量的最新值呢？可以通过下面这张图得出答案。image: /article_image/java-concurrent-memory-model...." }, { "title": "输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。", "url": "/posts/JZ42-double-points/", "categories": "算法, 双指针", "tags": "算法", "date": "2020-08-30 12:30:00 +0800", "snippet": "public class JZ42 { /** * solution: double points, one is in the array leftmost, other is in the array rightmost. * two points move to centre gradually. * * @param array * @param sum * @return */ public ArrayList&amp;lt;Integer&amp;gt; FindNumbersWithSum(int[] ar..." }, { "title": "输出所有和为S的连续正数序列。", "url": "/posts/JZ41-slide-windows/", "categories": "算法, 双指针", "tags": "算法", "date": "2020-08-28 00:58:00 +0800", "snippet": "public class JZ41 { /** * solution: slide windows(double point). two points just can move to right. * * @param sum * @return */ public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindContinuousSequence(int sum) { ArrayList&amp;lt;ArrayList&amp;lt;Int..." }, { "title": "判断二叉树是否为平衡二叉树", "url": "/posts/JZ39-balance-binary-tree/", "categories": "算法, 树", "tags": "算法", "date": "2020-08-19 20:55:00 +0800", "snippet": " public class JZ39 { // 平衡二叉树定义：对于树中任意一个节点，它的两个子树的高度差&amp;lt;=1 // 解法：通过深度优先搜索算法，递归的求出两个子节点的高度，比较高度差是否超过1 public boolean IsBalanced_Solution(TreeNode root) { int high = calcHigh(root); return high != -1; } private int calcHigh(TreeNode ..." } ]
